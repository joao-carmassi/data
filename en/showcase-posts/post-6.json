{
  "title": "Cybersecurity Essentials for Modern Applications",
  "date": "3 Jan 2024",
  "banner": {
    "src": "https://deifkwefumgah.cloudfront.net/shadcnblocks/block/placeholder-dark-6.svg",
    "alt": "Cybersecurity shield"
  },
  "sections": [
    {
      "id": "security-fundamentals",
      "title": "The Critical Importance of Application Security",
      "markdown": "## The Current Threat Landscape\n\n> There are two types of companies: those that have been hacked, and those that don't know they've been hacked. ‚Äî John Chambers, Cisco\n\n### Security Breach Statistics (2023-2024)\n\n- **68%** of organizations experienced a security breach in the past year\n- **$4.45M** average cost of a data breach (IBM)\n- **277 days** average time to identify and contain a breach\n- **43%** of cyberattacks target small businesses\n- **95%** of breaches are caused by human error\n\n### Real-World Impact\n\n**Major Breaches:**\n\n| Company | Year | Records Exposed | Cost | Vulnerability |\n|---------|------|-----------------|------|---------------|\n| **Yahoo** | 2013 | 3 billion | $350M | Weak encryption |\n| **Equifax** | 2017 | 147 million | $1.4B | Unpatched software |\n| **Capital One** | 2019 | 100 million | $270M | Misconfigured firewall |\n| **SolarWinds** | 2020 | 18,000 orgs | Billions | Supply chain attack |\n| **LastPass** | 2022 | Encrypted vaults | Unknown | MFA bypass |\n\n## The Security-First Mindset\n\nSecurity must be integrated into every phase of development:\n\n```\n‚ùå Security as an afterthought:\nDesign ‚Üí Develop ‚Üí Test ‚Üí Deploy ‚Üí [Add Security]\n\n‚úÖ Security by design:\nDesign + Security ‚Üí Develop + Security ‚Üí Test + Security ‚Üí Deploy + Security ‚Üí Monitor\n```\n\n### The OWASP Top 10 (2023 Edition)\n\n1. **Broken Access Control** (34% of applications)\n2. **Cryptographic Failures** (29%)\n3. **Injection** (27%)\n4. **Insecure Design** (24%)\n5. **Security Misconfiguration** (19%)\n6. **Vulnerable Components** (18%)\n7. **Identification & Authentication Failures** (14%)\n8. **Software & Data Integrity Failures** (10%)\n9. **Security Logging & Monitoring Failures** (9%)\n10. **Server-Side Request Forgery (SSRF)** (8%)\n\n![Security Threats](https://deifkwefumgah.cloudfront.net/shadcnblocks/block/placeholder-dark-6.svg)"
    },
    {
      "id": "authentication-authorization",
      "title": "Authentication & Authorization Done Right",
      "markdown": "### Password Security Best Practices\n\n**Never Do This:**\n```typescript\n// ‚ùå Storing plain text passwords\nconst user = {\n  email: 'user@example.com',\n  password: 'mysecretpassword123'\n};\nawait db.users.insert(user);\n```\n\n**Always Do This:**\n```typescript\nimport bcrypt from 'bcrypt';\nimport { z } from 'zod';\n\n// Password validation schema\nconst PasswordSchema = z.string()\n  .min(12, 'Password must be at least 12 characters')\n  .regex(/[A-Z]/, 'Must contain uppercase letter')\n  .regex(/[a-z]/, 'Must contain lowercase letter')\n  .regex(/[0-9]/, 'Must contain number')\n  .regex(/[^A-Za-z0-9]/, 'Must contain special character');\n\ninterface CreateUserInput {\n  email: string;\n  password: string;\n}\n\nclass AuthService {\n  private readonly SALT_ROUNDS = 12;\n\n  async hashPassword(password: string): Promise<string> {\n    PasswordSchema.parse(password);\n    return bcrypt.hash(password, this.SALT_ROUNDS);\n  }\n\n  async verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n  }\n\n  async createUser({ email, password }: CreateUserInput) {\n    const hashedPassword = await this.hashPassword(password);\n    \n    return db.users.insert({\n      email,\n      password: hashedPassword,\n      createdAt: new Date(),\n      mfaEnabled: false\n    });\n  }\n}\n```\n\n### Multi-Factor Authentication (MFA)\n\n```typescript\nimport speakeasy from 'speakeasy';\nimport qrcode from 'qrcode';\n\nclass MFAService {\n  async setupMFA(userId: string): Promise<{ secret: string; qrCode: string }> {\n    const secret = speakeasy.generateSecret({\n      name: 'MyApp',\n      issuer: 'MyCompany',\n      length: 32\n    });\n\n    const qrCode = await qrcode.toDataURL(secret.otpauth_url!);\n\n    await db.users.update(userId, {\n      mfaSecret: await encrypt(secret.base32),\n      mfaEnabled: false\n    });\n\n    return { secret: secret.base32, qrCode };\n  }\n\n  async verifyMFA(userId: string, token: string): Promise<boolean> {\n    const user = await db.users.findById(userId);\n    if (!user.mfaSecret) return false;\n\n    const secret = await decrypt(user.mfaSecret);\n\n    return speakeasy.totp.verify({\n      secret,\n      encoding: 'base32',\n      token,\n      window: 1\n    });\n  }\n}\n```\n\n### JWT Token Security\n\n```typescript\nimport { SignJWT, jwtVerify, type JWTPayload } from 'jose';\n\ninterface TokenPayload extends JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n}\n\nclass JWTService {\n  private readonly secret: Uint8Array;\n  private readonly ACCESS_TOKEN_EXPIRY = '15m';\n  private readonly REFRESH_TOKEN_EXPIRY = '7d';\n\n  constructor(secretKey: string) {\n    this.secret = new TextEncoder().encode(secretKey);\n  }\n\n  async createAccessToken(payload: TokenPayload): Promise<string> {\n    return new SignJWT(payload)\n      .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })\n      .setIssuedAt()\n      .setExpirationTime(this.ACCESS_TOKEN_EXPIRY)\n      .setIssuer('myapp.com')\n      .setAudience('myapp-api')\n      .sign(this.secret);\n  }\n\n  async verifyAccessToken(token: string): Promise<TokenPayload | null> {\n    try {\n      const { payload } = await jwtVerify(token, this.secret, {\n        issuer: 'myapp.com',\n        audience: 'myapp-api'\n      });\n      return payload as TokenPayload;\n    } catch {\n      return null;\n    }\n  }\n}\n```\n\n### Role-Based Access Control (RBAC)\n\n```typescript\nenum Permission {\n  READ_USER = 'read:user',\n  WRITE_USER = 'write:user',\n  DELETE_USER = 'delete:user',\n  READ_ADMIN = 'read:admin',\n  WRITE_ADMIN = 'write:admin'\n}\n\nconst rolePermissions: Record<string, Permission[]> = {\n  user: [Permission.READ_USER],\n  moderator: [Permission.READ_USER, Permission.WRITE_USER],\n  admin: [\n    Permission.READ_USER,\n    Permission.WRITE_USER,\n    Permission.DELETE_USER,\n    Permission.READ_ADMIN,\n    Permission.WRITE_ADMIN\n  ]\n};\n\nfunction authorize(requiredPermission: Permission) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const user = req.user;\n    \n    if (!user) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n\n    const permissions = rolePermissions[user.role] || [];\n    \n    if (!permissions.includes(requiredPermission)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n\n    next();\n  };\n}\n\n// Usage\napp.delete('/users/:id', \n  authenticate,\n  authorize(Permission.DELETE_USER),\n  deleteUserHandler\n);\n```\n\n:::alert\n**Critical:** Never trust client-side authorization checks. Always validate permissions on the server.\n:::"
    },
    {
      "id": "common-vulnerabilities",
      "title": "Preventing Common Security Vulnerabilities",
      "markdown": "## Injection Attacks\n\n### SQL Injection Prevention\n\n**Vulnerable Code:**\n```typescript\n// ‚ùå NEVER DO THIS\nconst getUserByEmail = async (email: string) => {\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  return db.query(query);\n};\n\n// Attacker input: ' OR '1'='1' --\n// Resulting query: SELECT * FROM users WHERE email = '' OR '1'='1' --'\n// Returns ALL users!\n```\n\n**Secure Code:**\n```typescript\n// ‚úÖ Use parameterized queries\nconst getUserByEmail = async (email: string) => {\n  const query = 'SELECT * FROM users WHERE email = $1';\n  return db.query(query, [email]);\n};\n\n// Or use an ORM\nimport { prisma } from './db';\n\nconst getUserByEmail = async (email: string) => {\n  return prisma.user.findUnique({ where: { email } });\n};\n```\n\n### Cross-Site Scripting (XSS)\n\n**Vulnerable Code:**\n```tsx\n// ‚ùå Dangerous HTML rendering\nconst Comment = ({ comment }: { comment: string }): React.ReactNode => (\n  <div dangerouslySetInnerHTML={{ __html: comment }} />\n);\n\n// Attacker input: <script>steal_cookies()</script>\n```\n\n**Secure Code:**\n```tsx\nimport DOMPurify from 'dompurify';\n\n// ‚úÖ Sanitize HTML\nconst Comment = ({ comment }: { comment: string }): React.ReactNode => {\n  const sanitized = DOMPurify.sanitize(comment, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],\n    ALLOWED_ATTR: ['href']\n  });\n  \n  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;\n};\n\n// ‚úÖ Or escape by default (React does this automatically)\nconst Comment = ({ comment }: { comment: string }): React.ReactNode => (\n  <div>{comment}</div>\n);\n```\n\n### Cross-Site Request Forgery (CSRF)\n\n```typescript\nimport csrf from 'csurf';\nimport cookieParser from 'cookie-parser';\n\nconst csrfProtection = csrf({ cookie: true });\n\napp.use(cookieParser());\n\napp.get('/api/csrf-token', csrfProtection, (req, res) => {\n  res.json({ csrfToken: req.csrfToken() });\n});\n\napp.post('/api/transfer', csrfProtection, async (req, res) => {\n  const { amount, toAccount } = req.body;\n  await processTransfer(amount, toAccount);\n  res.json({ success: true });\n});\n```\n\n### Insecure Direct Object References (IDOR)\n\n**Vulnerable:**\n```typescript\n// ‚ùå No authorization check\napp.get('/api/orders/:id', async (req, res) => {\n  const order = await db.orders.findById(req.params.id);\n  res.json(order);\n});\n// User can access ANY order by changing ID!\n```\n\n**Secure:**\n```typescript\n// ‚úÖ Verify ownership\napp.get('/api/orders/:id', authenticate, async (req, res) => {\n  const order = await db.orders.findOne({\n    id: req.params.id,\n    userId: req.user.id\n  });\n  \n  if (!order) {\n    return res.status(404).json({ error: 'Order not found' });\n  }\n  \n  res.json(order);\n});\n```\n\n## Security Headers\n\n```typescript\nimport helmet from 'helmet';\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n```\n\n## Input Validation\n\n```typescript\nimport { z } from 'zod';\n\nconst CreateUserSchema = z.object({\n  email: z.string().email().max(255),\n  password: z.string().min(12).max(128),\n  name: z.string().min(2).max(100),\n  age: z.number().int().min(13).max(150),\n  website: z.string().url().optional()\n});\n\napp.post('/api/users', async (req, res) => {\n  try {\n    const validated = CreateUserSchema.parse(req.body);\n    const user = await createUser(validated);\n    res.json(user);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return res.status(400).json({ \n        errors: error.errors.map(e => ({\n          field: e.path.join('.'),\n          message: e.message\n        }))\n      });\n    }\n    throw error;\n  }\n});\n```"
    },
    {
      "id": "security-best-practices",
      "title": "Security Best Practices & Monitoring",
      "markdown": "## Security Monitoring & Logging\n\n### Comprehensive Audit Logging\n\n```typescript\ninterface AuditLog {\n  timestamp: Date;\n  userId: string;\n  action: string;\n  resource: string;\n  resourceId: string;\n  ipAddress: string;\n  userAgent: string;\n  success: boolean;\n  metadata?: Record<string, any>;\n}\n\nclass AuditLogger {\n  async log(log: AuditLog): Promise<void> {\n    await db.auditLogs.insert({\n      ...log,\n      id: crypto.randomUUID(),\n      timestamp: new Date()\n    });\n\n    await siem.send(log);\n\n    if (this.isSuspicious(log)) {\n      await this.sendSecurityAlert(log);\n    }\n  }\n\n  private isSuspicious(log: AuditLog): boolean {\n    return (\n      log.action === 'login' && !log.success ||\n      log.action.includes('delete') ||\n      log.action.includes('admin')\n    );\n  }\n}\n```\n\n### Rate Limiting\n\n```typescript\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\n\nconst globalLimiter = rateLimit({\n  store: new RedisStore({ client: redis }),\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  message: 'Too many requests, please try again later'\n});\n\nconst authLimiter = rateLimit({\n  store: new RedisStore({ client: redis }),\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  skipSuccessfulRequests: true,\n  handler: (req, res) => {\n    auditLogger.log({\n      userId: req.body.email,\n      action: 'rate_limit_exceeded',\n      resource: 'auth',\n      resourceId: 'login',\n      ipAddress: req.ip,\n      userAgent: req.headers['user-agent'],\n      success: false\n    });\n    \n    res.status(429).json({\n      error: 'Too many login attempts, please try again in 15 minutes'\n    });\n  }\n});\n\napp.use('/api', globalLimiter);\napp.use('/api/auth/login', authLimiter);\n```\n\n## Security Checklist\n\n### Application Security\n\n‚úÖ **Authentication & Authorization**\n- Implement strong password requirements\n- Use bcrypt/argon2 for password hashing\n- Enable multi-factor authentication\n- Implement proper session management\n- Use secure, HttpOnly cookies\n- Implement RBAC/ABAC\n- Never expose user IDs in URLs\n\n‚úÖ **Input Validation & Sanitization**\n- Validate all user inputs\n- Use parameterized queries\n- Sanitize HTML\n- Implement CSRF protection\n- Validate file uploads\n- Rate limit all endpoints\n\n‚úÖ **Data Protection**\n- Encrypt sensitive data at rest\n- Use TLS 1.3 for data in transit\n- Implement proper key management\n- Regularly rotate secrets and keys\n- Never log sensitive data\n- Implement data retention policies\n\n‚úÖ **Infrastructure Security**\n- Keep dependencies updated\n- Run security scanners\n- Use security headers\n- Implement proper CORS policies\n- Use environment variables for secrets\n- Enable firewall and DDoS protection\n- Regular security audits\n\n‚úÖ **Monitoring & Response**\n- Implement comprehensive logging\n- Set up security alerts\n- Monitor for suspicious activity\n- Have incident response plan\n- Regular backup and recovery testing\n- Bug bounty program\n\n## Security Tools & Resources\n\n### Essential Tools\n\n| Tool | Purpose | Free Tier |\n|------|---------|--------|\n| **Snyk** | Dependency scanning | Yes |\n| **OWASP ZAP** | Vulnerability scanning | Yes |\n| **SonarQube** | Code quality & security | Yes |\n| **Burp Suite** | Web security testing | Limited |\n| **Dependabot** | Automated updates | Yes |\n| **npm audit** | Node.js vulnerabilities | Yes |\n\n### Compliance Standards\n\n- **GDPR**: European data protection\n- **HIPAA**: Healthcare data (US)\n- **PCI DSS**: Payment card data\n- **SOC 2**: Service organization controls\n- **ISO 27001**: Information security management\n\n## Conclusion\n\nSecurity is not optional‚Äîit's fundamental:\n\nüîí **Defense in Depth**: Multiple layers of security\nüîç **Continuous Monitoring**: Detect threats early  \nüìö **Security Training**: Educate your team\nüîÑ **Regular Updates**: Stay current with patches\n‚ö†Ô∏è **Incident Response**: Be prepared for breaches\n\n:::alert\n**Remember:** Security is a journey, not a destination. Stay vigilant, keep learning, and always assume you're a target.\n:::\n\n### Essential Resources\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/) - Critical security risks\n- [CWE Top 25](https://cwe.mitre.org/top25/) - Software weaknesses\n- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework) - Security guidelines\n- [Security Headers](https://securityheaders.com) - Test your headers\n- [Mozilla Observatory](https://observatory.mozilla.org) - Security scanner\n- [Awesome Security](https://github.com/sbilly/awesome-security) - Curated resources\n\nBuild secure applications from day one. Your users' trust depends on it."
    }
  ]
}
