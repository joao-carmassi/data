{
  "title": "Performance Optimization: Techniques for Faster Web Applications",
  "date": "1 Jan 2024",
  "banner": {
    "src": "https://deifkwefumgah.cloudfront.net/shadcnblocks/block/placeholder-dark-1.svg",
    "alt": "Performance optimization graph"
  },
  "sections": [
    {
      "id": "perf-intro",
      "title": "The Performance Imperative",
      "markdown": "> \"Performance is not just about making things fast. It's about respecting your users' time, data, and experience.\"\n\n## Why Performance Matters\n\n### Business Impact\n\n**Loading Time vs Conversion:**\n\n| Load Time | Bounce Rate | Conversion Impact |\n|-----------|-------------|-------------------|\n| **1-3s** | 32% | Baseline |\n| **1-5s** | 90% | -20% conversions |\n| **1-6s** | 106% | -40% conversions |\n| **1-10s** | 123% | -70% conversions |\n\n**Real-World Examples:**\n- **Pinterest** reduced load time by 40% â†’ **15% increase** in sign-ups\n- **COOK** reduced page load by 850ms â†’ **7% increase** in conversions\n- **BBC** lost **10% of users** for every additional second of load time\n- **Mobify** shaved 100ms â†’ **1.11% increase** in revenue\n\n### Core Web Vitals\n\nGoogle's performance metrics that affect SEO:\n\n**1. Largest Contentful Paint (LCP)**\n- Measures loading performance\n- **Good:** < 2.5s\n- **Poor:** > 4.0s\n\n**2. First Input Delay (FID)**\n- Measures interactivity\n- **Good:** < 100ms\n- **Poor:** > 300ms\n\n**3. Cumulative Layout Shift (CLS)**\n- Measures visual stability\n- **Good:** < 0.1\n- **Poor:** > 0.25\n\n### The Performance Budget\n\n```typescript\n// performance-budget.config.ts\nexport const performanceBudget = {\n  // Time budgets\n  lcp: 2500,        // 2.5s\n  fid: 100,         // 100ms\n  cls: 0.1,         // 0.1\n  ttfb: 600,        // 600ms\n  \n  // Size budgets\n  totalSize: 1500,  // 1.5MB\n  javascript: 500,  // 500KB\n  css: 100,         // 100KB\n  images: 800,      // 800KB\n  fonts: 100,       // 100KB\n  \n  // Request budgets\n  totalRequests: 50,\n  thirdParty: 10\n};\n```\n\n:::alert\n**Critical:** Measure before you optimize. Use real user monitoring (RUM) and synthetic testing to identify bottlenecks.\n:::"
    },
    {
      "id": "loading-optimization",
      "title": "Loading Performance Strategies",
      "markdown": "## Code Splitting & Lazy Loading\n\n### Route-Based Code Splitting\n\n```tsx\nimport { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport LoadingSpinner from './components/LoadingSpinner';\n\n// Lazy load route components\nconst Home = lazy(() => import('./pages/Home'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Profile = lazy(() => import('./pages/Profile'));\nconst Settings = lazy(() => import('./pages/Settings'));\n\nconst App = (): React.ReactNode => {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<LoadingSpinner />}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/profile\" element={<Profile />} />\n          <Route path=\"/settings\" element={<Settings />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n};\n```\n\n### Component-Level Lazy Loading\n\n```tsx\nimport { lazy, Suspense, useState } from 'react';\n\n// Heavy component loaded on demand\nconst HeavyChart = lazy(() => import('./components/HeavyChart'));\nconst VideoPlayer = lazy(() => import('./components/VideoPlayer'));\n\nconst Dashboard = (): React.ReactNode => {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      \n      {/* Load chart only when needed */}\n      <button onClick={() => setShowChart(true)}>\n        Show Analytics\n      </button>\n      \n      {showChart && (\n        <Suspense fallback={<div>Loading chart...</div>}>\n          <HeavyChart />\n        </Suspense>\n      )}\n    </div>\n  );\n};\n```\n\n### Dynamic Imports with Preloading\n\n```typescript\n// Preload on hover for instant loading\nfunction preloadComponent(factory: () => Promise<any>) {\n  let promise: Promise<any> | null = null;\n  \n  return {\n    load: () => {\n      if (!promise) {\n        promise = factory();\n      }\n      return promise;\n    },\n    preload: () => {\n      if (!promise) {\n        promise = factory();\n      }\n    }\n  };\n}\n\nconst DashboardLoader = preloadComponent(() => import('./Dashboard'));\n\n// Preload on link hover\n<Link \n  to=\"/dashboard\"\n  onMouseEnter={() => DashboardLoader.preload()}\n  onFocus={() => DashboardLoader.preload()}\n>\n  Dashboard\n</Link>\n```\n\n## Image Optimization\n\n### Modern Image Formats\n\n```tsx\ninterface OptimizedImageProps {\n  src: string;\n  alt: string;\n  width: number;\n  height: number;\n}\n\nconst OptimizedImage = ({ src, alt, width, height }: OptimizedImageProps): React.ReactNode => {\n  return (\n    <picture>\n      {/* Modern formats for supporting browsers */}\n      <source\n        srcSet={`${src}.avif`}\n        type=\"image/avif\"\n      />\n      <source\n        srcSet={`${src}.webp`}\n        type=\"image/webp\"\n      />\n      \n      {/* Fallback for older browsers */}\n      <img\n        src={`${src}.jpg`}\n        alt={alt}\n        width={width}\n        height={height}\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </picture>\n  );\n};\n```\n\n### Lazy Loading Images\n\n```tsx\nimport { useEffect, useRef, useState } from 'react';\n\nconst LazyImage = ({ src, alt, placeholder }: any): React.ReactNode => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [isInView, setIsInView] = useState(false);\n  const imgRef = useRef<HTMLImageElement>(null);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setIsInView(true);\n          observer.disconnect();\n        }\n      },\n      { rootMargin: '50px' } // Load 50px before entering viewport\n    );\n\n    if (imgRef.current) {\n      observer.observe(imgRef.current);\n    }\n\n    return () => observer.disconnect();\n  }, []);\n\n  return (\n    <div style={{ position: 'relative' }}>\n      {/* Low-quality placeholder */}\n      <img\n        src={placeholder}\n        alt={alt}\n        style={{\n          filter: isLoaded ? 'blur(0)' : 'blur(20px)',\n          transition: 'filter 0.3s'\n        }}\n      />\n      \n      {/* Actual image */}\n      {isInView && (\n        <img\n          ref={imgRef}\n          src={src}\n          alt={alt}\n          onLoad={() => setIsLoaded(true)}\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            opacity: isLoaded ? 1 : 0,\n            transition: 'opacity 0.3s'\n          }}\n        />\n      )}\n    </div>\n  );\n};\n```\n\n## Caching Strategies\n\n### Service Worker Caching\n\n```typescript\n// service-worker.ts\nconst CACHE_NAME = 'app-v1';\nconst urlsToCache = [\n  '/',\n  '/styles/main.css',\n  '/scripts/main.js'\n];\n\n// Install - cache assets\nself.addEventListener('install', (event: any) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME).then(cache => {\n      return cache.addAll(urlsToCache);\n    })\n  );\n});\n\n// Fetch - serve from cache, fallback to network\nself.addEventListener('fetch', (event: any) => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      // Cache hit - return response\n      if (response) {\n        return response;\n      }\n\n      return fetch(event.request).then(response => {\n        // Don't cache non-successful responses\n        if (!response || response.status !== 200) {\n          return response;\n        }\n\n        // Clone response and cache it\n        const responseToCache = response.clone();\n        caches.open(CACHE_NAME).then(cache => {\n          cache.put(event.request, responseToCache);\n        });\n\n        return response;\n      });\n    })\n  );\n});\n```\n\n### HTTP Caching Headers\n\n```typescript\n// Express middleware\napp.use((req, res, next) => {\n  // Static assets - cache for 1 year\n  if (req.url.match(/\\.(css|js|jpg|png|gif|ico|woff2?)$/)) {\n    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n  }\n  // HTML - revalidate\n  else if (req.url.match(/\\.html$/)) {\n    res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate');\n  }\n  // API - no cache\n  else if (req.url.startsWith('/api')) {\n    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n  }\n  \n  next();\n});\n```"
    },
    {
      "id": "runtime-performance",
      "title": "Runtime Performance Optimization",
      "markdown": "## React Performance Patterns\n\n### Memoization\n\n```tsx\nimport { memo, useMemo, useCallback, useState } from 'react';\n\n// Memoize expensive computations\nconst ExpensiveComponent = ({ data }: { data: number[] }): React.ReactNode => {\n  const processedData = useMemo(() => {\n    console.log('Processing data...');\n    return data\n      .filter(x => x > 0)\n      .map(x => x * 2)\n      .reduce((a, b) => a + b, 0);\n  }, [data]); // Only recompute when data changes\n\n  return <div>Result: {processedData}</div>;\n};\n\n// Memoize callbacks\nconst Parent = (): React.ReactNode => {\n  const [count, setCount] = useState(0);\n\n  // Without useCallback, new function on every render\n  const handleClick = useCallback(() => {\n    setCount(c => c + 1);\n  }, []); // Empty deps - function never changes\n\n  return <Child onClick={handleClick} />;\n};\n\n// Memoize component\nconst Child = memo(({ onClick }: { onClick: () => void }): React.ReactNode => {\n  console.log('Child rendered');\n  return <button onClick={onClick}>Click</button>;\n});\n// Only re-renders when onClick changes\n```\n\n### Virtual Scrolling\n\n```tsx\nimport { FixedSizeList } from 'react-window';\n\ninterface Item {\n  id: number;\n  name: string;\n}\n\nconst VirtualList = ({ items }: { items: Item[] }): React.ReactNode => {\n  const Row = ({ index, style }: any) => (\n    <div style={style}>\n      {items[index].name}\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={items.length}\n      itemSize={35}\n      width=\"100%\"\n    >\n      {Row}\n    </FixedSizeList>\n  );\n};\n// Renders only visible items (50-100) instead of all (10,000+)\n```\n\n### Debouncing & Throttling\n\n```typescript\n// Debounce - wait for user to stop typing\nfunction debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n// Throttle - limit execution rate\nfunction throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean;\n  \n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n}\n\n// Usage\nconst SearchInput = (): React.ReactNode => {\n  const [query, setQuery] = useState('');\n\n  const debouncedSearch = useMemo(\n    () => debounce((q: string) => {\n      console.log('Searching for:', q);\n      // API call here\n    }, 300),\n    []\n  );\n\n  return (\n    <input\n      value={query}\n      onChange={(e) => {\n        setQuery(e.target.value);\n        debouncedSearch(e.target.value);\n      }}\n    />\n  );\n};\n```\n\n## Bundle Size Optimization\n\n### Tree Shaking\n\n```typescript\n// âŒ Imports entire library\nimport _ from 'lodash';\nconst result = _.debounce(fn, 100);\n\n// âœ… Imports only what's needed\nimport debounce from 'lodash/debounce';\nconst result = debounce(fn, 100);\n\n// âœ… Even better - use native or lighter alternatives\nconst debounce = (fn, ms) => {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn(...args), ms);\n  };\n};\n```\n\n### Bundle Analysis\n\n```bash\n# Webpack Bundle Analyzer\nnpm install --save-dev webpack-bundle-analyzer\n\n# package.json\n\"scripts\": {\n  \"analyze\": \"webpack-bundle-analyzer dist/stats.json\"\n}\n```\n\n## Performance Monitoring\n\n```typescript\n// Web Vitals tracking\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\nfunction sendToAnalytics(metric: any) {\n  // Send to your analytics endpoint\n  fetch('/analytics', {\n    method: 'POST',\n    body: JSON.stringify(metric)\n  });\n}\n\ngetCLS(sendToAnalytics);\ngetFID(sendToAnalytics);\ngetFCP(sendToAnalytics);\ngetLCP(sendToAnalytics);\ngetTTFB(sendToAnalytics);\n\n// Custom performance marks\nperformance.mark('api-call-start');\nawait fetchData();\nperformance.mark('api-call-end');\n\nperformance.measure('api-call', 'api-call-start', 'api-call-end');\nconst measure = performance.getEntriesByName('api-call')[0];\nconsole.log(`API call took ${measure.duration}ms`);\n```\n\n## Conclusion\n\nPerformance optimization is an ongoing process:\n\nâš¡ **Measure First**: Use real data to identify bottlenecks\nðŸŽ¯ **Set Budgets**: Define performance goals\nðŸ”§ **Optimize Strategically**: Focus on high-impact changes\nðŸ“Š **Monitor Continuously**: Track metrics over time\nðŸ”„ **Iterate**: Performance is never \"done\"\n\n### Essential Resources\n\n- [web.dev](https://web.dev/performance/) - Performance guides\n- [Lighthouse](https://developers.google.com/web/tools/lighthouse) - Automated auditing\n- [WebPageTest](https://www.webpagetest.org) - Performance testing\n- [Bundle Phobia](https://bundlephobia.com) - Check package sizes\n- [Can I Use](https://caniuse.com) - Browser compatibility\n- [Awesome Web Performance](https://github.com/davidsonfellipe/awesome-wpo) - Resources\n\nRemember: Every millisecond matters. Optimize for your users."
    }
  ]
}
