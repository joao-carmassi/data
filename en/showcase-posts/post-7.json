{
  "title": "Performance Optimization: Techniques for Faster Web Applications",
  "date": "1 Jan 2024",
  "banner": {
    "src": "https://deifkwefumgah.cloudfront.net/shadcnblocks/block/placeholder-dark-1.svg",
    "alt": "Performance optimization graph"
  },
  "sections": [
    {
      "title": "The Performance Imperative",
      "markdown": "\u003e \"Performance is not just about making things fast. It\u0027s about respecting your users\u0027 time, data, and experience.\"\n\n## Why Performance Matters\n\n###  Business Impact\n\n**Loading Time vs Conversion:**\n\n| Load Time | Bounce Rate | Conversion Impact |\n|-----------|-------------|-------------------|\n| **1-3s** | 32% | Baseline |\n| **1-5s** | 90% | -20% conversions |\n| **1-6s** | 106% | -40% conversions |\n| **1-10s** | 123% | -70% conversions |\n\n**Real-World Examples:**\n- **Pinterest** reduced load time by 40% ‚Üí **15% increase** in sign-ups\n- **COOK** reduced page load by 850ms ‚Üí **7% increase** in conversions\n- **BBC** lost **10% of users** for every additional second of load time\n- **Mobify** shaved 100ms ‚Üí **1.11% increase** in revenue\n\n### Core Web Vitals\n\nGoogle\u0027s performance metrics that affect SEO:\n\n**1. Largest Contentful Paint (LCP)**\n- Measures loading performance\n- **Good:** \u003c 2.5s\n- **Poor:** \u003e 4.0s\n\n**2. First Input Delay (FID)**\n- Measures interactivity\n- **Good:** \u003c 100ms\n- **Poor:** \u003e 300ms\n\n**3. Cumulative Layout Shift (CLS)**\n- Measures visual stability\n- **Good:** \u003c 0.1\n- **Poor:** \u003e 0.25\n\n### The Performance Budget\n\n```typescript\n// performance-budget.config.ts\nexport const performanceBudget = {\n  // Time budgets\n  lcp: 2500,        // 2.5s\n  fid: 100,         // 100ms\n  cls: 0.1,         // 0.1\n  ttfb: 600,        // 600ms\n  \n  // Size budgets\n  totalSize: 1500,  // 1.5MB\n  javascript: 500,  // 500KB\n  css: 100,         // 100KB\n  images: 800,      // 800KB\n  fonts: 100,       // 100KB\n  \n  // Request budgets\n  totalRequests: 50,\n  thirdParty: 10\n};\n```\n\n:::alert\n**Critical:** Measure before you optimize. Use real user monitoring (RUM) and synthetic testing to identify bottlenecks.\n:::"
    },
    {
      "title": "Loading Performance Strategies",
      "markdown": "```tsx\nimport { lazy, Suspense } from \u0027react\u0027;\nimport { BrowserRouter, Routes, Route } from \u0027react-router-dom\u0027;\nimport LoadingSpinner from \u0027./components/LoadingSpinner\u0027;\n\n// Lazy load route components\nconst Home = lazy(() =\u003e import(\u0027./pages/Home\u0027));\nconst Dashboard = lazy(() =\u003e import(\u0027./pages/Dashboard\u0027));\nconst Profile = lazy(() =\u003e import(\u0027./pages/Profile\u0027));\nconst Settings = lazy(() =\u003e import(\u0027./pages/Settings\u0027));\n\nconst App = (): React.ReactNode =\u003e {\n  return (\n    \u003cBrowserRouter\u003e\n      \u003cSuspense fallback={\u003cLoadingSpinner /\u003e}\u003e\n        \u003cRoutes\u003e\n          \u003cRoute path=\"/\" element={\u003cHome /\u003e} /\u003e\n          \u003cRoute path=\"/dashboard\" element={\u003cDashboard /\u003e} /\u003e\n          \u003cRoute path=\"/profile\" element={\u003cProfile /\u003e} /\u003e\n          \u003cRoute path=\"/settings\" element={\u003cSettings /\u003e} /\u003e\n        \u003c/Routes\u003e\n      \u003c/Suspense\u003e\n    \u003c/BrowserRouter\u003e\n  );\n};\n```\n\n### Component-Level Lazy Loading\n\n```tsx\nimport { lazy, Suspense, useState } from \u0027react\u0027;\n\n// Heavy component loaded on demand\nconst HeavyChart = lazy(() =\u003e import(\u0027./components/HeavyChart\u0027));\nconst VideoPlayer = lazy(() =\u003e import(\u0027./components/VideoPlayer\u0027));\n\nconst Dashboard = (): React.ReactNode =\u003e {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eDashboard\u003c/h1\u003e\n      \n      {/* Load chart only when needed */}\n      \u003cbutton onClick={() =\u003e setShowChart(true)}\u003e\n        Show Analytics\n      \u003c/button\u003e\n      \n      {showChart \u0026\u0026 (\n        \u003cSuspense fallback={\u003cdiv\u003eLoading chart...\u003c/div\u003e}\u003e\n          \u003cHeavyChart /\u003e\n        \u003c/Suspense\u003e\n      )}\n    \u003c/div\u003e\n  );\n};\n```\n\n### Dynamic Imports with Preloading\n\n```typescript\n// Preload on hover for instant loading\nfunction preloadComponent(factory: () =\u003e Promise\u003cany\u003e) {\n  let promise: Promise\u003cany\u003e | null = null;\n  \n  return {\n    load: () =\u003e {\n      if (!promise) {\n        promise = factory();\n      }\n      return promise;\n    },\n    preload: () =\u003e {\n      if (!promise) {\n        promise = factory();\n      }\n    }\n  };\n}\n\nconst DashboardLoader = preloadComponent(() =\u003e import(\u0027./Dashboard\u0027));\n\n// Preload on link hover\n\u003cLink \n  to=\"/dashboard\"\n  onMouseEnter={() =\u003e DashboardLoader.preload()}\n  onFocus={() =\u003e DashboardLoader.preload()}\n\u003e\n  Dashboard\n\u003c/Link\u003e\n```\n\n## Image Optimization\n\n### Modern Image Formats\n\n```tsx\ninterface OptimizedImageProps {\n  src: string;\n  alt: string;\n  width: number;\n  height: number;\n}\n\nconst OptimizedImage = ({ src, alt, width, height }: OptimizedImageProps): React.ReactNode =\u003e {\n  return (\n    \u003cpicture\u003e\n      {/* Modern formats for supporting browsers */}\n      \u003csource\n        srcSet={`${src}.avif`}\n        type=\"image/avif\"\n      /\u003e\n      \u003csource\n        srcSet={`${src}.webp`}\n        type=\"image/webp\"\n      /\u003e\n      \n      {/* Fallback for older browsers */}\n      \u003cimg\n        src={`${src}.jpg`}\n        alt={alt}\n        width={width}\n        height={height}\n        loading=\"lazy\"\n        decoding=\"async\"\n      /\u003e\n    \u003c/picture\u003e\n  );\n};\n```\n\n### Lazy Loading Images\n\n```tsx\nimport { useEffect, useRef, useState } from \u0027react\u0027;\n\nconst LazyImage = ({ src, alt, placeholder }: any): React.ReactNode =\u003e {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [isInView, setIsInView] = useState(false);\n  const imgRef = useRef\u003cHTMLImageElement\u003e(null);\n\n  useEffect(() =\u003e {\n    const observer = new IntersectionObserver(\n      ([entry]) =\u003e {\n        if (entry.isIntersecting) {\n          setIsInView(true);\n          observer.disconnect();\n        }\n      },\n      { rootMargin: \u002750px\u0027 } // Load 50px before entering viewport\n    );\n\n    if (imgRef.current) {\n      observer.observe(imgRef.current);\n    }\n\n    return () =\u003e observer.disconnect();\n  }, []);\n\n  return (\n    \u003cdiv style={{ position: \u0027relative\u0027 }}\u003e\n      {/* Low-quality placeholder */}\n      \u003cimg\n        src={placeholder}\n        alt={alt}\n        style={{\n          filter: isLoaded ? \u0027blur(0)\u0027 : \u0027blur(20px)\u0027,\n          transition: \u0027filter 0.3s\u0027\n        }}\n      /\u003e\n      \n      {/* Actual image */}\n      {isInView \u0026\u0026 (\n        \u003cimg\n          ref={imgRef}\n          src={src}\n          alt={alt}\n          onLoad={() =\u003e setIsLoaded(true)}\n          style={{\n            position: \u0027absolute\u0027,\n            top: 0,\n            left: 0,\n            opacity: isLoaded ? 1 : 0,\n            transition: \u0027opacity 0.3s\u0027\n          }}\n        /\u003e\n      )}\n    \u003c/div\u003e\n  );\n};\n```\n\n## Caching Strategies\n\n### Service Worker Caching\n\n```typescript\n// service-worker.ts\nconst CACHE_NAME = \u0027app-v1\u0027;\nconst urlsToCache = [\n  \u0027/\u0027,\n  \u0027/styles/main.css\u0027,\n  \u0027/scripts/main.js\u0027\n];\n\n// Install - cache assets\nself.addEventListener(\u0027install\u0027, (event: any) =\u003e {\n  event.waitUntil(\n    caches.open(CACHE_NAME).then(cache =\u003e {\n      return cache.addAll(urlsToCache);\n    })\n  );\n});\n\n// Fetch - serve from cache, fallback to network\nself.addEventListener(\u0027fetch\u0027, (event: any) =\u003e {\n  event.respondWith(\n    caches.match(event.request).then(response =\u003e {\n      // Cache hit - return response\n      if (response) {\n        return response;\n      }\n\n      return fetch(event.request).then(response =\u003e {\n        // Don\u0027t cache non-successful responses\n        if (!response || response.status !== 200) {\n          return response;\n        }\n\n        // Clone response and cache it\n        const responseToCache = response.clone();\n        caches.open(CACHE_NAME).then(cache =\u003e {\n          cache.put(event.request, responseToCache);\n        });\n\n        return response;\n      });\n    })\n  );\n});\n```\n\n### HTTP Caching Headers\n\n```typescript\n// Express middleware\napp.use((req, res, next) =\u003e {\n  // Static assets - cache for 1 year\n  if (req.url.match(/\\.(css|js|jpg|png|gif|ico|woff2?)$/)) {\n    res.setHeader(\u0027Cache-Control\u0027, \u0027public, max-age=31536000, immutable\u0027);\n  }\n  // HTML - revalidate\n  else if (req.url.match(/\\.html$/)) {\n    res.setHeader(\u0027Cache-Control\u0027, \u0027public, max-age=0, must-revalidate\u0027);\n  }\n  // API - no cache\n  else if (req.url.startsWith(\u0027/api\u0027)) {\n    res.setHeader(\u0027Cache-Control\u0027, \u0027no-store, no-cache, must-revalidate\u0027);\n  }\n  \n  next();\n});\n```"
    },
    {
      "title": "Runtime Performance Optimization",
      "markdown": "```tsx\nimport { memo, useMemo, useCallback, useState } from \u0027react\u0027;\n\n// Memoize expensive computations\nconst ExpensiveComponent = ({ data }: { data: number[] }): React.ReactNode =\u003e {\n  const processedData = useMemo(() =\u003e {\n    console.log(\u0027Processing data...\u0027);\n    return data\n      .filter(x =\u003e x \u003e 0)\n      .map(x =\u003e x * 2)\n      .reduce((a, b) =\u003e a + b, 0);\n  }, [data]); // Only recompute when data changes\n\n  return \u003cdiv\u003eResult: {processedData}\u003c/div\u003e;\n};\n\n// Memoize callbacks\nconst Parent = (): React.ReactNode =\u003e {\n  const [count, setCount] = useState(0);\n\n  // Without useCallback, new function on every render\n  const handleClick = useCallback(() =\u003e {\n    setCount(c =\u003e c + 1);\n  }, []); // Empty deps - function never changes\n\n  return \u003cChild onClick={handleClick} /\u003e;\n};\n\n// Memoize component\nconst Child = memo(({ onClick }: { onClick: () =\u003e void }): React.ReactNode =\u003e {\n  console.log(\u0027Child rendered\u0027);\n  return \u003cbutton onClick={onClick}\u003eClick\u003c/button\u003e;\n});\n// Only re-renders when onClick changes\n```\n\n### Virtual Scrolling\n\n```tsx\nimport { FixedSizeList } from \u0027react-window\u0027;\n\ninterface Item {\n  id: number;\n  name: string;\n}\n\nconst VirtualList = ({ items }: { items: Item[] }): React.ReactNode =\u003e {\n  const Row = ({ index, style }: any) =\u003e (\n    \u003cdiv style={style}\u003e\n      {items[index].name}\n    \u003c/div\u003e\n  );\n\n  return (\n    \u003cFixedSizeList\n      height={600}\n      itemCount={items.length}\n      itemSize={35}\n      width=\"100%\"\n    \u003e\n      {Row}\n    \u003c/FixedSizeList\u003e\n  );\n};\n// Renders only visible items (50-100) instead of all (10,000+)\n```\n\n### Debouncing \u0026 Throttling\n\n```typescript\n// Debounce - wait for user to stop typing\nfunction debounce\u003cT extends (...args: any[]) =\u003e any\u003e(\n  func: T,\n  wait: number\n): (...args: Parameters\u003cT\u003e) =\u003e void {\n  let timeout: NodeJS.Timeout;\n  \n  return (...args: Parameters\u003cT\u003e) =\u003e {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =\u003e func(...args), wait);\n  };\n}\n\n// Throttle - limit execution rate\nfunction throttle\u003cT extends (...args: any[]) =\u003e any\u003e(\n  func: T,\n  limit: number\n): (...args: Parameters\u003cT\u003e) =\u003e void {\n  let inThrottle: boolean;\n  \n  return (...args: Parameters\u003cT\u003e) =\u003e {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() =\u003e (inThrottle = false), limit);\n    }\n  };\n}\n\n// Usage\nconst SearchInput = (): React.ReactNode =\u003e {\n  const [query, setQuery] = useState(\u0027\u0027);\n\n  const debouncedSearch = useMemo(\n    () =\u003e debounce((q: string) =\u003e {\n      console.log(\u0027Searching for:\u0027, q);\n      // API call here\n    }, 300),\n    []\n  );\n\n  return (\n    \u003cinput\n      value={query}\n      onChange={(e) =\u003e {\n        setQuery(e.target.value);\n        debouncedSearch(e.target.value);\n      }}\n    /\u003e\n  );\n};\n```\n\n## Bundle Size Optimization\n\n### Tree Shaking\n\n```typescript\n// ‚ùå Imports entire library\nimport _ from \u0027lodash\u0027;\nconst result = _.debounce(fn, 100);\n\n// ‚úÖ Imports only what\u0027s needed\nimport debounce from \u0027lodash/debounce\u0027;\nconst result = debounce(fn, 100);\n\n// ‚úÖ Even better - use native or lighter alternatives\nconst debounce = (fn, ms) =\u003e {\n  let timeout;\n  return (...args) =\u003e {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =\u003e fn(...args), ms);\n  };\n};\n```\n\n### Bundle Analysis\n\n```bash\n# Webpack Bundle Analyzer\nnpm install --save-dev webpack-bundle-analyzer\n\n# package.json\n\"scripts\": {\n  \"analyze\": \"webpack-bundle-analyzer dist/stats.json\"\n}\n```\n\n## Performance Monitoring\n\n```typescript\n// Web Vitals tracking\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from \u0027web-vitals\u0027;\n\nfunction sendToAnalytics(metric: any) {\n  // Send to your analytics endpoint\n  fetch(\u0027/analytics\u0027, {\n    method: \u0027POST\u0027,\n    body: JSON.stringify(metric)\n  });\n}\n\ngetCLS(sendToAnalytics);\ngetFID(sendToAnalytics);\ngetFCP(sendToAnalytics);\ngetLCP(sendToAnalytics);\ngetTTFB(sendToAnalytics);\n\n// Custom performance marks\nperformance.mark(\u0027api-call-start\u0027);\nawait fetchData();\nperformance.mark(\u0027api-call-end\u0027);\n\nperformance.measure(\u0027api-call\u0027, \u0027api-call-start\u0027, \u0027api-call-end\u0027);\nconst measure = performance.getEntriesByName(\u0027api-call\u0027)[0];\nconsole.log(`API call took ${measure.duration}ms`);\n```\n\n## Conclusion\n\nPerformance optimization is an ongoing process:\n\n‚ö° **Measure First**: Use real data to identify bottlenecks\nüéØ **Set Budgets**: Define performance goals\nüîß **Optimize Strategically**: Focus on high-impact changes\nüìä **Monitor Continuously**: Track metrics over time\nüîÑ **Iterate**: Performance is never \"done\"\n\n### Essential Resources\n\n- [web.dev](https://web.dev/performance/) - Performance guides\n- [Lighthouse](https://developers.google.com/web/tools/lighthouse) - Automated auditing\n- [WebPageTest](https://www.webpagetest.org) - Performance testing\n- [Bundle Phobia](https://bundlephobia.com) - Check package sizes\n- [Can I Use](https://caniuse.com) - Browser compatibility\n- [Awesome Web Performance](https://github.com/davidsonfellipe/awesome-wpo) - Resources\n\nRemember: Every millisecond matters. Optimize for your users."
    }
  ]
}
